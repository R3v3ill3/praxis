// frontend/pages/app/campaign/MessagingDevelopmentChatPage.jsx
import React, { useState, useEffect, useContext, useRef } from 'react';
import { useNavigate } from 'react-router-dom'; // Import useNavigate
import CampaignContext from '@/contexts/CampaignContext';
// Assuming sendMessagingChatTurn is in:
// import { sendMessagingChatTurn } from '@/api/messaging-chat';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/Card';
import { Textarea } from '@/components/ui/Textarea';
import { Button } from '@/components/ui/Button';
import { ScrollArea } from '@/components/ui/scroll-area'; // For better message display
import { useToast } from '@/components/ui/use-toast'; // For error notifications

// --- MOCK API CALL (Remove this when you have your actual API helper) ---
// Ensure your actual sendMessagingChatTurn function in @/api/messaging-chat.js
// sends `campaignId`, `conversationHistory`, `knownInputs`, AND `classification`
// to the `/api/messaging-chat` backend.
async function sendMessagingChatTurn({ campaignId, conversationHistory, knownInputs, classification }) {
  console.log("MOCK sendMessagingChatTurn called with:", { campaignId, conversationHistory, knownInputs, classification });
  // Simulate API delay
  await new Promise(resolve => setTimeout(resolve, 1000));

  // Simulate backend response structure from "Version A" of messaging-chat.js
  if (conversationHistory.length === 0 && knownInputs.issueName) { // Initial call
    return {
      aiMessage: `ðŸ‘‹ Let's work on your messaging strategy for "${knownInputs.issueName}". I see this is a "${classification?.primary_type || 'general'}" campaign. First, can you tell me more about the specific change or solution your campaign is proposing?`,
      updatedKnownInputs: knownInputs,
      fieldInFocus: "proposedChange", // Example: assuming backend wants 'proposedChange' next
      isComplete: false,
    };
  }
  // Simulate a subsequent response
  return {
    aiMessage: "That's helpful! Now, could you describe the primary audience you want to reach?",
    updatedKnownInputs: { ...knownInputs, proposedChange: conversationHistory.find(m => m.role === 'user')?.content || "User provided change" },
    fieldInFocus: "primaryAudience",
    isComplete: false, // Or true if conditions are met
  };
}
// --- END MOCK API CALL ---

export default function MessagingDevelopmentChatPage() {
  const {
    campaignId,
    summary,
    classification,
    goals,
    initialMessagingInputs, // Get the comprehensive initial state from context
    updateMessagingInputs, // To update context if needed, though this page manages its own 'knownInputs' for the chat session
  } = useContext(CampaignContext);

  const navigate = useNavigate();
  const { toast } = useToast();

  const [conversationHistory, setConversationHistory] = useState([]);
  const [userInput, setUserInput] = useState('');
  const [knownInputs, setKnownInputs] = useState(null); // Initialize as null, to be set by pre-filling
  const [currentFieldInFocus, setCurrentFieldInFocus] = useState(null);
  const [isChatComplete, setIsChatComplete] = useState(false);

  // Initialization and loop prevention state
  const initCalledRef = useRef(false); // Tracks if the initial API call has been attempted
  const [isInitializingChat, setIsInitializingChat] = useState(true); // True while pre-filling and making the first call
  const [initializationStatus, setInitializationStatus] = useState('pending'); // 'pending', 'success', 'error'

  const messagesEndRef = useRef(null); // For scrolling to the bottom of messages

  // Scroll to bottom when new messages are added
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [conversationHistory]);


  // Effect for Initializing Chat and Pre-filling knownInputs
  useEffect(() => {
    if (!campaignId || !summary || !classification || !goals || !initialMessagingInputs) {
      // Not all required context data is available yet
      if (campaignId && (!summary || !classification || !goals)) {
         // If campaignId is present but other data is missing, it might indicate an issue
         // or the user navigated here prematurely.
         setInitializationStatus('error');
         setIsInitializingChat(false);
         toast({
            variant: "destructive",
            title: "Missing Campaign Data",
            description: "Essential campaign summary, classification, or goals are missing. Please ensure previous steps are complete.",
         });
      }
      return;
    }

    if (initCalledRef.current || knownInputs !== null) {
      // Already initialized or initialization was already attempted
      setIsInitializingChat(false);
      return;
    }

    console.log("MessagingDevelopmentChatPage: Initializing and pre-filling knownInputs...");
    setIsInitializingChat(true);
    initCalledRef.current = true; // Mark that initialization attempt has started

    // --- Task 2: Refine pre-filling of knownInputs ---
    // Start with a deep copy of the comprehensive initialMessagingInputs from context
    const prefilledInputs = JSON.parse(JSON.stringify(initialMessagingInputs));

    // Map summary and goals data to the backend's expected fields
    // (as defined in "Version A" of messaging-chat.js - REQUIRED_KEYS are issueName, geographicContext, proposedChange, primaryAudience, desiredOutcome)
    if (summary) {
      prefilledInputs.issueName = summary.purpose || prefilledInputs.issueName;
      prefilledInputs.geographicContext = summary.location || prefilledInputs.geographicContext;
      prefilledInputs.primaryAudience = summary.audience || prefilledInputs.primaryAudience;
      // `campaignObjective` in CampaignContext's initialMessagingInputsState can be mapped from summary.intent
      prefilledInputs.campaignObjective = summary.intent || prefilledInputs.campaignObjective;
    }

    if (goals && goals.length > 0) {
      // For 'desiredOutcome', we might concatenate goal labels or use the primary one.
      // "Version A" of backend expects 'desiredOutcome' as a string.
      prefilledInputs.desiredOutcome = goals.map(g => g.label).join('; ') || prefilledInputs.desiredOutcome;

      // 'proposedChange' might also come from a primary goal or a specific summary field if available.
      // If summary.proposedChange exists (as in some earlier component versions), prefer that.
      prefilledInputs.proposedChange = summary.proposedChange || goals[0]?.label || prefilledInputs.proposedChange;
    }

    // Note: audienceProfile and deliveryContext are complex objects.
    // If there's pre-fillable data for them in summary/goals, add that logic here.
    // For now, they'll start with empty strings as per initialMessagingInputs.

    setKnownInputs(prefilledInputs);
    console.log("Pre-filled knownInputs:", prefilledInputs);
    console.log("Classification to be sent:", classification);

    // Trigger initial message from the backend
    // Pass an empty message, empty actual history, the prefilled inputs, and classification
    handleApiCall('', [], prefilledInputs, classification, true);

  }, [campaignId, summary, classification, goals, initialMessagingInputs, knownInputs, toast]); // Added knownInputs to deps to avoid re-triggering if it's already set.

  const handleApiCall = async (userMessage = '', currentHistory, currentKnownInputs, currentClassification, isInitialCall = false) => {
    if (!campaignId) {
      toast({ variant: "destructive", title: "Error", description: "Campaign ID is missing." });
      if (isInitialCall) {
        setIsInitializingChat(false);
        setInitializationStatus('error');
      }
      return;
    }
    if (!currentClassification) {
        toast({ variant: "destructive", title: "Error", description: "Campaign classification is missing." });
        if (isInitialCall) {
          setIsInitializingChat(false);
          setInitializationStatus('error');
        }
        return;
    }


    setLoading(true);
    let newHistory = [...currentHistory];
    if (userMessage) {
      newHistory = [...newHistory, { role: 'user', content: userMessage }];
    }

    try {
      // --- Task 1: Add `classification` to the API payload ---
      const response = await sendMessagingChatTurn({
        campaignId,
        conversationHistory: newHistory,
        knownInputs: currentKnownInputs,
        classification: currentClassification, // Crucial addition
      });

      // Update conversation history with AI's response
      const updatedHistoryWithAI = [...newHistory, { role: 'assistant', content: response.aiMessage }];
      setConversationHistory(updatedHistoryWithAI);

      // Update knownInputs (backend might have filled some based on AI interaction)
      // and also reflect the user's message if the backend isn't doing smart parsing for the current field.
      // "Version A" of backend sends back its current view of knownInputs.
      setKnownInputs(response.updatedKnownInputs);

      // Update context if we want these inputs to persist more broadly
      // updateMessagingInputs(response.updatedKnownInputs); // Optional: decide if/when to do this

      setCurrentFieldInFocus(response.fieldInFocus);
      setIsChatComplete(response.isComplete);

      if (isInitialCall) {
        setInitializationStatus('success');
      }

    } catch (err) {
      console.error('Messaging chat API error:', err);
      const errorMessage = err.details || err.message || 'Failed to get a response from the assistant.';
      toast({
        variant: "destructive",
        title: "Chat Error",
        description: errorMessage,
      });
      // Add AI-like error message to chat for user
      setConversationHistory(prevHistory => [...prevHistory, { role: 'assistant', content: `I'm having a bit of trouble connecting. Please try again in a moment. (Error: ${errorMessage})` }]);
      if (isInitialCall) {
        setInitializationStatus('error');
      }
    } finally {
      setLoading(false);
      if (isInitialCall) {
        setIsInitializingChat(false);
      }
      setUserInput(''); // Clear user input after sending
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!userInput.trim() || loading || isChatComplete) return;
    // --- Task 3: Loop prevention is handled by `initCalledRef` for initial call,
    // and `loading` state for subsequent calls.
    handleApiCall(userInput.trim(), conversationHistory, knownInputs, classification);
  };

  // Render loading state during initialization
  if (isInitializingChat && initializationStatus === 'pending') {
    return (
      <div className="container py-8 max-w-3xl mx-auto text-center">
        <Card><CardHeader><CardTitle>Initializing Messaging Assistant...</CardTitle></CardHeader>
          <CardContent><p>Loading campaign data and preparing the chat. Please wait.</p></CardContent>
        </Card>
      </div>
    );
  }

  // Render error state if initialization failed
  if (initializationStatus === 'error' && conversationHistory.length === 0) {
    return (
      <div className="container py-8 max-w-3xl mx-auto text-center">
        <Card>
          <CardHeader><CardTitle>Initialization Failed</CardTitle></CardHeader>
          <CardContent>
            <p className="text-red-600">Could not initialize the chat. Please ensure all previous campaign steps are complete and try again.</p>
            <Button onClick={() => navigate(-1)} className="mt-4">Go Back</Button>
          </CardContent>
        </Card>
      </div>
    );
  }
  // Basic check if essential data for chat is present AFTER initialization attempt
  if (!campaignId || !knownInputs) {
    return (
      <div className="p-6 max-w-xl mx-auto">
        <Card>
          <CardHeader><CardTitle>Error</CardTitle></CardHeader>
          <CardContent>
            <p>Critical campaign data for the chat is missing. Please try re-initializing the campaign step.</p>
            <Button onClick={() => navigate('/app/campaign/new')} className="mt-4">Start New Campaign</Button>
          </CardContent>
        </Card>
      </div>
    );
  }


  return (
    <div className="container py-8 flex flex-col h-[calc(100vh-150px)] max-h-[800px]"> {/* Adjust height as needed */}
      <Card className="max-w-3xl mx-auto flex flex-col flex-grow w-full">
        <CardHeader>
          <CardTitle>Develop Messaging Guide - Step 1: AI Chat</CardTitle>
          <p className="text-sm text-muted-foreground">
            Let's chat to gather the key details for your messaging.
            {currentFieldInFocus && !isChatComplete && (
              <span className="block text-xs font-semibold text-blue-600 mt-1">Focusing on: {currentFieldInFocus}</span>
            )}
          </p>
        </CardHeader>
        <ScrollArea className="flex-grow p-4"> {/* Scrollable message area */}
          <CardContent className="space-y-4">
            {conversationHistory.map((msg, idx) => (
              <Card key={idx} className={`max-w-[85%] ${msg.role === 'user' ? 'ml-auto bg-primary text-primary-foreground' : 'mr-auto bg-muted'}`}>
                <CardContent className="p-3">
                  <p className="text-sm whitespace-pre-wrap">
                    {/* No need for "You:" or "Assistant:" prefixes if styling handles it */}
                    {msg.content}
                  </p>
                </CardContent>
              </Card>
            ))}
            <div ref={messagesEndRef} /> {/* Anchor for scrolling */}
          </CardContent>
        </ScrollArea>

        {!isChatComplete && (
          <div className="p-4 border-t">
            <form onSubmit={handleSubmit} className="flex items-center gap-2">
              <Textarea
                value={userInput}
                onChange={(e) => setUserInput(e.target.value)}
                placeholder={loading ? "Assistant is thinking..." : "Type your reply..."}
                rows={2}
                className="flex-grow resize-none"
                disabled={loading || isChatComplete}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSubmit(e);
                  }
                }}
              />
              <Button type="submit" disabled={loading || !userInput.trim() || isChatComplete}>
                {loading ? 'Sending...' : 'Send'}
              </Button>
            </form>
          </div>
        )}

        {isChatComplete && (
          <div className="p-4 text-center border-t">
            <p className="text-green-600 font-semibold">
              âœ… All necessary information has been collected!
            </p>
            <p className="text-sm text-muted-foreground mt-1">
              You can now proceed to generate your messaging guide.
            </p>
            <Button onClick={() => navigate(`/app/campaign/${campaignId}/messaging-guide`)} className="mt-4">
              Generate Messaging Guide
            </Button>
          </div>
        )}
      </Card>
    </div>
  );
}
