// frontend/src/pages/MessagingDevelopmentChatPage.jsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useCampaign } from '../contexts/CampaignContext';
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from '../components/ui/Card';
import { Button } from '../components/ui/Button';
import { Input } from '../components/ui/Input';
import { ScrollArea } from '../components/ui/scroll-area';
import { useToast } from '../components/ui/use-toast';
import { useNavigate } from 'react-router-dom';
import { SendHorizonal } from 'lucide-react';

async function sendMessagingChatMessage(payload) {
  const response = await fetch('/api/messaging-chat', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({
      error: 'Network error or non-JSON server response.',
      details: `Status: ${response.status}`
    }));
    const errorMessage = errorData.error || errorData.details || `Server error: ${response.status}`;
    throw new Error(errorMessage);
  }
  return response.json();
}

const MessagingDevelopmentChatPage = () => {
  const {
    campaignId,
    summary,
    goals,
    messagingInputs,
    initialMessagingInputs: contextInitialMessagingInputs,
    updateMessagingInputs,
  } = useCampaign();
  const navigate = useNavigate();
  const { toast } = useToast();

  const [conversation, setConversation] = useState([]);
  const [currentUserMessage, setCurrentUserMessage] = useState('');
  
  const [isLoadingNextMessage, setIsLoadingNextMessage] = useState(false); // For when user sends a message
  
  // States for controlling the ONE-TIME initialization
  const [isInitializingChat, setIsInitializingChat] = useState(false);
  const [initializationStatus, setInitializationStatus] = useState('pending'); // 'pending', 'success', 'failed'
  const [initializationError, setInitializationError] = useState(null);

  const [isComplete, setIsComplete] = useState(false);
  const [currentFieldInFocus, setCurrentFieldInFocus] = useState(null);

  const chatContainerRef = useRef(null);
  const initCalledRef = useRef(false); // Ref to ensure initializeChat is called only once

  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight;
    }
  }, [conversation]);

  // This useCallback is fine, its own deps will cause it to update,
  // but the useEffect below is what controls its execution.
  const initializeChat = useCallback(async () => {
    console.log("CALLBACK: initializeChat function body executing.");
    if (!campaignId) {
      setInitializationError("Campaign ID is missing.");
      setInitializationStatus('failed');
      setIsInitializingChat(false);
      return;
    }
    
    setInitializationError(null); // Clear previous error

    let currentKnownInputs = messagingInputs;

    // Populate initial messaging inputs if they are not already set or are empty.
    // This check needs to be robust.
    const isMessagingInputsEffectivelyEmpty = !currentKnownInputs || 
                                            (typeof currentKnownInputs === 'object' && Object.keys(currentKnownInputs).length === 0) ||
                                            currentKnownInputs === contextInitialMessagingInputs; // If it's still the default empty object from context

    if (isMessagingInputsEffectivelyEmpty) {
      console.log("MessagingDevelopmentChatPage: Initializing messagingInputs in context for chat.");
      const initialData = { ...(contextInitialMessagingInputs || {}) };
      if (summary) {
        initialData.issueName = summary.purpose || initialData.issueName || '';
        initialData.primaryAudience = summary.audience || initialData.primaryAudience || '';
      }
      if (goals && goals.length > 0) {
        initialData.desiredOutcome = goals.sort((a,b) => a.rank - b.rank).map(g => g.label).join('; ') || initialData.desiredOutcome || '';
      }
      // Only update if there's actually something to update to avoid potential loops if updateMessagingInputs itself is a dep
      if(JSON.stringify(currentKnownInputs) !== JSON.stringify(initialData)) {
          updateMessagingInputs(initialData);
      }
      currentKnownInputs = initialData;
    } else {
      console.log("MessagingDevelopmentChatPage: Using existing messagingInputs for chat initial call.", currentKnownInputs);
    }
    
    const payload = {
      campaignId,
      conversationHistory: [],
      currentUserMessage: '',
      knownInputs: currentKnownInputs, // Send the potentially updated or existing inputs
    };

    try {
      console.log("FETCH: Initializing chat, sending to /api/messaging-chat:", payload);
      const response = await sendMessagingChatMessage(payload);
      console.log("FETCH: Initial response from /api/messaging-chat:", response);

      if (response.aiMessage) {
        setConversation([{ role: 'assistant', content: response.aiMessage }]);
      }
      // Even if inputs were updated from context, the backend response is the source of truth after a call
      if (response.updatedKnownInputs) {
        updateMessagingInputs(response.updatedKnownInputs);
      }
      setCurrentFieldInFocus(response.fieldInFocus || null);
      setIsComplete(response.isComplete || false);
      setInitializationStatus('success');

    } catch (error) {
      console.error("FETCH ERROR: Error initializing chat:", error);
      const errorMessage = error.message || "An unknown error occurred during chat initialization.";
      setInitializationError(errorMessage);
      setInitializationStatus('failed');
      toast({
        variant: "destructive",
        title: "Error Initializing Chat",
        description: errorMessage,
      });
      setConversation([{ role: 'assistant', content: `Sorry, I couldn't start our conversation: ${errorMessage}. Please wait for rate limits to clear and then refresh the page.` }]);
    } finally {
      setIsInitializingChat(false);
    }
  }, [campaignId, summary, goals, messagingInputs, contextInitialMessagingInputs, updateMessagingInputs, toast]);

  useEffect(() => {
    console.log("EFFECT: Checking conditions for initializeChat", { campaignId, status: initializationStatus, isInitializing: isInitializingChat, initCalled: initCalledRef.current });
    if (campaignId && !initCalledRef.current && !isInitializingChat) {
      console.log("EFFECT: Conditions MET. Setting initCalledRef to true and calling initializeChat.");
      initCalledRef.current = true; // Set ref immediately to prevent re-entry
      setIsInitializingChat(true); // Set loading state
      initializeChat();
    } else {
      console.log("EFFECT: Conditions NOT MET or already called. Not calling initializeChat.");
    }
    // This useEffect should run when campaignId becomes available.
    // It uses initCalledRef (a ref, not state) to ensure initializeChat() is invoked only once.
    // isInitializingChat is used to prevent overlapping calls if campaignId changes rapidly (unlikely here).
  }, [campaignId, initializeChat, isInitializingChat]); // Removed initializationStatus from here to prevent re-triggering on status change from within initializeChat


  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!currentUserMessage.trim() || isLoadingNextMessage || isComplete || initializationStatus !== 'success' || isInitializingChat) return;

    const newUserMessage = { role: 'user', content: currentUserMessage.trim() };
    setConversation(prevConversation => [...prevConversation, newUserMessage]);
    setCurrentUserMessage('');
    setIsLoadingNextMessage(true);

    const currentMessagingInputs = messagingInputs || contextInitialMessagingInputs || {};
    const payload = {
      campaignId,
      conversationHistory: [...conversation, newUserMessage], // Pass the up-to-the-moment conversation
      knownInputs: currentMessagingInputs,
    };

    try {
      // ... (rest of handleSendMessage remains the same as your last version) ...
      console.log("SEND: Sending message to /api/messaging-chat:", payload);
      const response = await sendMessagingChatMessage(payload);
      console.log("SEND: Response from /api/messaging-chat:", response);

      if (response.aiMessage) {
        setConversation(prev => [...prev, { role: 'assistant', content: response.aiMessage }]);
      }
      if (response.updatedKnownInputs) {
        updateMessagingInputs(response.updatedKnownInputs);
      }
      setCurrentFieldInFocus(response.fieldInFocus || null);
      setIsComplete(response.isComplete || false);

      if (response.isComplete) {
        toast({
          title: "Information Complete!",
          description: "We've gathered all the necessary details for the messaging guide.",
        });
      }
    } catch (error) {
      console.error("SEND ERROR: Error sending message:", error);
      const errorMessage = error.message || "An unknown error occurred while sending the message.";
      toast({ variant: "destructive", title: "Chat Error", description: errorMessage });
      setConversation(prev => [...prev, { role: 'assistant', content: `Sorry, I encountered an issue: ${errorMessage}` }]);
    } finally {
      setIsLoadingNextMessage(false);
    }
  };
  
  if (isInitializingChat && initializationStatus === 'pending') {
    return (
        <div className="p-6 max-w-3xl mx-auto text-center">
            <Card>
                <CardHeader><CardTitle>Initializing Chat...</CardTitle></CardHeader>
                <CardContent><p>Please wait. The assistant is getting ready...</p></CardContent>
            </Card>
        </div>
    );
  }
  
  if (initializationStatus === 'failed') {
      return (
          <div className="p-6 max-w-3xl mx-auto text-center">
              <Card>
                  <CardHeader><CardTitle className="text-red-600">Chat Initialization Failed</CardTitle></CardHeader>
                  <CardContent>
                      <p>{initializationError || "An unknown error occurred."}</p>
                      <p className="mt-2 text-sm text-gray-600">This might be due to API rate limits or a configuration issue. Please wait a few moments and then refresh the page.</p>
                      <Button onClick={() => window.location.reload()} className="mt-4">Refresh Page</Button>
                  </CardContent>
              </Card>
          </div>
      );
  }

  if (!campaignId && !isInitializingChat) {
    return (
      <div className="p-6 max-w-xl mx-auto text-center">
        <Card><CardHeader><CardTitle>Error</CardTitle></CardHeader>
          <CardContent><p>No active campaign found. Please start a new campaign.</p>
            <Button onClick={() => navigate('/app/campaign/new')} className="mt-4">Start New Campaign</Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  // If we reach here and initializationStatus is still 'pending' but not isInitializingChat, it means something is off,
  // but the main loading/error states should have caught it. Default to not showing chat if not successfully initialized.
  if (initializationStatus !== 'success') {
      // This case should ideally be covered by the loading or error states above.
      // If it still loops, this might be a fallback.
      return (
          <div className="p-6 max-w-3xl mx-auto text-center">
              <Card>
                  <CardHeader><CardTitle>Loading Chat...</CardTitle></CardHeader>
                  <CardContent><p>Preparing chat interface. If this persists, please refresh.</p></CardContent>
              </Card>
          </div>
      );
  }


  return (
    <div className="p-4 md:p-6 max-w-3xl mx-auto flex flex-col h-[calc(100vh-100px)]">
      <Card className="flex-grow flex flex-col">
        <CardHeader>
          <CardTitle className="text-2xl">Develop Messaging (AI Chat)</CardTitle>
          <CardDescription>
            Let's gather the info for your messaging guide. Campaign ID: {campaignId}
            {currentFieldInFocus && !isComplete && <span className="block text-sm text-blue-600">I'm currently asking about: {currentFieldInFocus.replace("audienceProfile.", "Audience ").replace("deliveryContext.", "Delivery ")}</span>}
          </CardDescription>
        </CardHeader>
        <CardContent className="flex-grow flex flex-col overflow-hidden">
          <ScrollArea className="flex-grow mb-4 pr-4" ref={chatContainerRef}>
            {conversation.map((msg, index) => (
              <div key={index} className={`mb-3 p-3 rounded-lg max-w-[85%] ${
                msg.role === 'user' ? 'bg-blue-500 text-white ml-auto' : msg.content.startsWith("Sorry, I couldn't start") ? 'bg-red-100 text-red-700 mr-auto' : 'bg-gray-200 text-gray-800 mr-auto'
              }`}>
                <p className="text-sm whitespace-pre-wrap">{msg.content}</p>
              </div>
            ))}
            {isLoadingNextMessage && <div className="mb-3 p-3 rounded-lg max-w-[85%] bg-gray-200 text-gray-800 mr-auto"><p className="text-sm italic">Assistant is typing...</p></div>}
          </ScrollArea>

          {isComplete ? (
            <div className="text-center p-4 border-t">
              <p className="text-green-600 font-semibold mb-3">All information has been collected!</p>
              <Button onClick={() => navigate('/app/campaign/message')}>Proceed to Generate Messaging Guide</Button>
            </div>
          ) : (
            <form onSubmit={handleSendMessage} className="flex items-center gap-2 border-t pt-4">
              <Input
                type="text"
                placeholder={"Your response..."} // Simplified placeholder
                value={currentUserMessage}
                onChange={(e) => setCurrentUserMessage(e.target.value)}
                disabled={isLoadingNextMessage || isComplete || isInitializingChat || initializationStatus !== 'success'}
                className="flex-grow"
              />
              <Button type="submit" disabled={isLoadingNextMessage || isComplete || isInitializingChat || initializationStatus !== 'success' || !currentUserMessage.trim()} size="icon">
                <SendHorizonal className="h-5 w-5" />
              </Button>
            </form>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default MessagingDevelopmentChatPage;
