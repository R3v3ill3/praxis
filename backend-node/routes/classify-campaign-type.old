// backend-node/routes/classify-campaign-type.js

import express from 'express';
import path from 'path';
import fs from 'fs/promises';
import { fileURLToPath } from 'url';

const router = express.Router();

// --- Determine Directory Path ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const dataDir = path.join(__dirname, '..', 'data');

// --- Load JSON Data Asynchronously ---
let campaignData = {
    types: [], subtypes: [], useCases: [], goals: [], goalMappings: [],
    isLoaded: false, loadError: null,
    typesMap: new Map(), subtypesMap: new Map(), useCasesMap: new Map(),
    goalsMap: new Map(), goalMappingsMap: new Map()
};

async function loadData() {
    const filesToLoad = [
        { key: 'types', file: 'campaign_types.json' },
        { key: 'subtypes', file: 'campaign_subtypes.json' },
        { key: 'useCases', file: 'campaign_use_cases.json' },
        { key: 'goals', file: 'campaign_goals.json' },
        { key: 'goalMappings', file: 'goal_mappings.json' },
    ];
    try {
        console.log(`[classify-campaign] INFO: Attempting to load JSON data from ${dataDir}`);
        const results = await Promise.allSettled(
            filesToLoad.map(item =>
                fs.readFile(path.join(dataDir, item.file), 'utf-8').then(JSON.parse)
            )
        );
        let allSucceeded = true;
        results.forEach((result, index) => {
            const item = filesToLoad[index];
            if (result.status === 'fulfilled') campaignData[item.key] = result.value;
            else {
                allSucceeded = false;
                console.error(`[classify-campaign] ERROR: Failed to load ${item.file}:`, result.reason);
                campaignData.loadError = campaignData.loadError || result.reason;
            }
        });
        if (!allSucceeded) throw campaignData.loadError || new Error("One or more data files failed to load.");

        // --- Populate maps ---
        campaignData.types.forEach(t => campaignData.typesMap.set(t.id, t));
        campaignData.subtypes.forEach(st => {
            if (st.id === 'envrionmental_political') { st.id = 'environmental_political'; st.type_id = 'environmental'; }
            campaignData.subtypesMap.set(st.id, st);
        });
        campaignData.useCases.forEach(uc => campaignData.useCasesMap.set(uc.id, uc));

        // 1. Build goalsMap first, correcting typos and mapping name/id to canonical ID
        campaignData.goals.forEach(g => {
            let canonId = g.id;
            if (g.id === 'poltical_decision') {
                 // console.warn(`[classify-campaign] WARN: Correcting goal ID typo 'poltical_decision' to 'political_decision' in goalsMap.`);
                 canonId = 'political_decision';
            }
             campaignData.goalsMap.set(g.name.toLowerCase(), canonId);
             campaignData.goalsMap.set(g.id.toLowerCase(), canonId); // Map original (potentially misspelled) ID
             if (canonId !== g.id) {
                 campaignData.goalsMap.set(canonId.toLowerCase(), canonId); // Ensure canonical ID maps to itself
             }
        });
        console.log("[classify-campaign] DEBUG: goalsMap populated:", Array.from(campaignData.goalsMap.entries()));


        // 2. Build goalMappingsMap using the canonical IDs looked up via goalsMap
        campaignData.goalMappings.forEach(gm => {
            const priorities = new Map();
            if(Array.isArray(gm.goals)) {
                gm.goals.forEach(g => {
                    // Find the canonical ID using the (potentially misspelled) ID from the mapping file
                    const canonicalGoalId = campaignData.goalsMap.get(g.goal_id.toLowerCase());
                    if (canonicalGoalId) {
                         // Store the priority using the CORRECTED canonical ID
                         priorities.set(canonicalGoalId, g.priority);
                    } else {
                         // This warning should now only appear if a goal_id truly doesn't exist in campaign_goals.json
                         console.warn(`[classify-campaign] WARN: Goal ID "${g.goal_id}" in goal_mappings for use case "${gm.use_case_id}" could not be mapped to a canonical ID.`);
                    }
                });
            } else {
                 console.warn(`[classify-campaign] WARN: goals array missing or invalid for use_case_id "${gm.use_case_id}" in goal_mappings.json`);
            }
            campaignData.goalMappingsMap.set(gm.use_case_id, priorities);
        });
        console.log("[classify-campaign] DEBUG: goalMappingsMap populated for use case 'corporate_action':", campaignData.goalMappingsMap.get('corporate_action'));
        // --- End populating maps ---

        campaignData.isLoaded = true;
        campaignData.loadError = null;
        console.log(`[classify-campaign] INFO: Successfully processed relational JSON data files.`);
    } catch (err) {
        campaignData.loadError = err;
        console.error(`[classify-campaign] ERROR: Critical failure during data loading or processing:`, err);
    }
}
loadData();
// --- End Load JSON Data ---


// --- Classification Logic (Same as classify_campaign_ranked_goals_v2) ---
function classifyCampaign(summary) {
    // 1. Normalize User Goals from Summary (Order implies rank)
    const userRankedGoalIds = [];
    if (Array.isArray(summary.goals)) {
        summary.goals.forEach((goalName, index) => {
            // Use goalsMap for normalization
            const goalId = campaignData.goalsMap.get(String(goalName).toLowerCase().trim());
            if (goalId) {
                userRankedGoalIds.push({ id: goalId, rank: index + 1 }); // Store ID and rank
            } else {
                 console.warn(`[classify-campaign] WARN: User goal "${goalName}" (rank ${index + 1}) not found in goalsMap during classification.`);
            }
        });
    }
    console.log(`[classify-campaign] INFO: Normalized User Ranked Goal IDs for classification:`, userRankedGoalIds);

    if (userRankedGoalIds.length === 0) {
        console.log(`[classify-campaign] INFO: No valid/recognized goals provided by user. Cannot classify based on goals.`);
        return null;
    }

    // 2. Score Use Cases based on Goal Alignment and User Ranking
    let bestUseCaseId = null;
    let highestScore = -1;

    campaignData.goalMappingsMap.forEach((useCaseGoalPriorities, useCaseId) => {
        let currentScore = 0;
        let matchedGoalCount = 0;

        userRankedGoalIds.forEach(userGoal => {
            // Check against the priorities map (which now uses canonical IDs)
            if (useCaseGoalPriorities.has(userGoal.id)) {
                matchedGoalCount++;
                const predefinedPriority = useCaseGoalPriorities.get(userGoal.id);
                let goalScore = (9 - predefinedPriority);
                // Adjust rank multiplier calculation slightly for clarity and edge cases
                const rankWeight = userGoal.rank <= 4 ? (5 - userGoal.rank) / 4 : 0.1; // Ranks 1-4 get 1.0, 0.75, 0.5, 0.25; higher ranks get 0.1
                goalScore *= rankWeight;
                currentScore += goalScore;
            }
        });

        // Only consider use cases that match at least one goal
        if (matchedGoalCount > 0 && currentScore > highestScore) {
            highestScore = currentScore;
            bestUseCaseId = useCaseId;
             // console.log(`[classify-campaign] DEBUG: New best use case candidate: ${bestUseCaseId} (Score: ${highestScore.toFixed(2)})`);
        }
    });

    if (!bestUseCaseId) {
        console.log(`[classify-campaign] INFO: No matching use case found based on goal priorities and ranking.`);
        return null;
    }

    console.log(`[classify-campaign] INFO: Best matching Use Case ID determined by ranked goals: ${bestUseCaseId} (Score: ${highestScore.toFixed(2)})`);

    // 3. Trace Hierarchy Backwards
    const bestUseCase = campaignData.useCasesMap.get(bestUseCaseId);
    if (!bestUseCase) {
        console.error(`[classify-campaign] ERROR: Data inconsistency - Could not find use case details for ID: ${bestUseCaseId}`);
        return null;
    }
    // Refined subtype matching
    const bestSubtype = campaignData.subtypes.find(st =>
        st.id.toLowerCase() === bestUseCase.subtype_id.toLowerCase() || // Check full ID first
        st.name.toLowerCase() === bestUseCase.subtype_id.toLowerCase() || // Check name
        st.id.toLowerCase().endsWith(`_${bestUseCase.subtype_id.toLowerCase()}`) // Check suffix
    );
    if (!bestSubtype) {
        console.error(`[classify-campaign] ERROR: Data inconsistency - Could not find subtype details for subtype_id: "${bestUseCase.subtype_id}" (from use case ${bestUseCaseId})`);
        return null;
    }
    const bestType = campaignData.typesMap.get(bestSubtype.type_id);
    if (!bestType) {
        console.error(`[classify-campaign] ERROR: Data inconsistency - Could not find type details for type_id: "${bestSubtype.type_id}" (from subtype ${bestSubtype.id})`);
        return null;
    }

    console.log(`[classify-campaign] INFO: Classification Path: Type=${bestType.name}(${bestType.id}), Subtype=${bestSubtype.name}(${bestSubtype.id}), UseCase=${bestUseCase.name}(${bestUseCase.id})`);

    // 4. Construct Result Object
    return {
        id: bestUseCaseId,
        primary_type: bestType.name,
        secondary_type: bestSubtype.name,
        sub_type: bestUseCase.name,
        type_id: bestType.id,
        subtype_id: bestSubtype.id,
        confidence: highestScore
    };
}
// --- End Classification Logic ---


// --- Route Handler (No changes needed here) ---
router.post('/', (req, res) => {
    const requestTimestamp = new Date().toISOString();
    console.log(`[${requestTimestamp}] INFO: Received POST /api/classify-campaign-type`);

    if (!campaignData.isLoaded) {
        console.error(`[${requestTimestamp}] ERROR: Classification unavailable - data not loaded. Load Error: ${campaignData.loadError}`);
        return res.status(500).json({ error: 'Classification service unavailable (data loading error).' });
    }

    const { summary } = req.body;

    if (!summary || typeof summary !== 'object' || !summary.purpose || !summary.audience || !summary.target || !Array.isArray(summary.goals) || summary.goals.length === 0) {
      console.warn(`[${requestTimestamp}] WARN: Received invalid or incomplete summary object. Must include non-empty goals array. Keys:`, Object.keys(summary));
      return res.status(400).json({ error: 'Missing expected fields (purpose, audience, target, non-empty goals array) in summary object.' });
    }
     console.log(`[${requestTimestamp}] DEBUG: Received summary goals (order implies rank):`, summary.goals);

    const result = classifyCampaign(summary);

    if (!result) {
      console.log(`[${requestTimestamp}] INFO: Classification result: No match found.`);
      return res.status(200).json({
        match: null,
        confidence: 0.0,
        message: 'Could not classify campaign type based on provided summary goals.'
      });
    } else {
      console.log(`[${requestTimestamp}] INFO: Classification result: Match found - Type: ${result.primary_type}, SubType: ${result.secondary_type}, UseCase: ${result.sub_type}`);
      return res.status(200).json({
        match: result,
        message: 'Campaign type classification successful.'
      });
    }
});
// --- End Route Handler ---

export default router;
